//
//  CustardInterfaceKeyEditor.swift
//  MainApp
//
//  Created by ensan on 2021/04/23.
//  Copyright Â© 2021 ensan. All rights reserved.
//

import AzooKeyUtils
import CustardKit
import Foundation
import KeyboardViews
import SwiftUI
import SwiftUIUtils

private enum LabelType {
    case text, systemImage, mainAndSub
}

fileprivate extension CustardInterfaceKey {
    enum SystemKey { case system }
    enum CustomKey { case custom }

    subscript(key: CustomKey) -> CustardInterfaceCustomKey {
        get {
            if case let .custom(value) = self {
                return value
            }
            return .init(design: .init(label: .text(""), color: .normal), press_actions: [], longpress_actions: .none, variations: [])
        }
        set {
            self = .custom(newValue)
        }
    }

    subscript(key: SystemKey) -> CustardInterfaceSystemKey {
        get {
            if case let .system(value) = self {
                return value
            }
            return .enter
        }
        set {
            self = .system(newValue)
        }
    }
}

fileprivate extension FlickKeyPosition {
    var flickDirection: FlickDirection? {
        switch self {
        case .left: return .left
        case .top: return .top
        case .right: return .right
        case .bottom: return .bottom
        case .center: return nil
        }
    }
}

fileprivate extension CustardInterfaceCustomKey {
    subscript(direction: FlickDirection) -> CustardInterfaceVariationKey {
        get {
            if let variation = self.variations.first(where: {$0.type == .flickVariation(direction)})?.key {
                return variation
            }
            return .init(design: .init(label: .text("")), press_actions: [], longpress_actions: .none)
        }
        set {
            if let index = self.variations.firstIndex(where: {$0.type == .flickVariation(direction)}) {
                self.variations[index].key = newValue
            } else {
                self.variations.append(.init(type: .flickVariation(direction), key: newValue))
            }
        }
    }

    enum LabelTextKey { case labelText }
    enum LabelImageNameKey { case labelImageName }
    enum LabelTypeKey { case labelType }
    enum LabelMainKey { case labelMain }
    enum LabelSubKey { case labelSub }
    enum PressActionKey { case pressAction }
    enum InputActionKey { case inputAction }
    enum LongpressActionKey { case longpressAction }

    subscript(label: LabelTextKey, position: FlickKeyPosition) -> String {
        get {
            if let direction = position.flickDirection {
                return self[direction][.labelText]
            }
            if case let .text(value) = self.design.label {
                return value
            }
            return ""
        }
        set {
            if let direction = position.flickDirection {
                self[direction][.labelText] = newValue
            } else {
                self.design.label = .text(newValue)
            }
        }
    }

    subscript(label: LabelImageNameKey, position: FlickKeyPosition) -> String {
        get {
            if let direction = position.flickDirection {
                return self[direction][.labelImageName]
            }
            if case let .systemImage(value) = self.design.label {
                return value
            }
            return ""
        }
        set {
            if let direction = position.flickDirection {
                self[direction][.labelImageName] = newValue
            } else {
                self.design.label = .systemImage(newValue)
            }
        }
    }

    subscript(label: LabelMainKey, position: FlickKeyPosition) -> String {
        get {
            if let direction = position.flickDirection {
                return self[direction][.labelMain]
            }
            if case let .mainAndSub(value, _) = self.design.label {
                return value
            }
            return ""
        }
        set {
            if let direction = position.flickDirection {
                self[direction][.labelMain] = newValue
            } else if case let .mainAndSub(_, variations) = self.design.label {
                self.design.label = .mainAndSub(newValue, variations)
            } else {
                self.design.label = .mainAndSub(newValue, "")
            }
        }
    }

    subscript(label: LabelSubKey, position: FlickKeyPosition) -> String {
        get {
            if let direction = position.flickDirection {
                return self[direction][.labelSub]
            }
            if case let .mainAndSub(_, value) = self.design.label {
                return value
            }
            return ""
        }
        set {
            if let direction = position.flickDirection {
                self[direction][.labelSub] = newValue
            } else if case let .mainAndSub(main, _) = self.design.label {
                self.design.label = .mainAndSub(main, newValue)
            } else {
                self.design.label = .mainAndSub("", newValue)
            }
        }
    }

    subscript(label: LabelTypeKey, position: FlickKeyPosition) -> LabelType {
        get {
            if let direction = position.flickDirection {
                return self[direction][.labelType]
            }
            switch self.design.label {
            case .systemImage: return .systemImage
            case .text: return .text
            case .mainAndSub: return .mainAndSub
            }
        }
        set {
            if let direction = position.flickDirection {
                self[direction][.labelType] = newValue
            } else {
                switch newValue {
                case .text:
                    self.design.label = .text("")
                case .systemImage:
                    self.design.label = .systemImage("circle.fill")
                case .mainAndSub:
                    self.design.label = .mainAndSub("A", "BC")
                }
            }
        }
    }

    subscript(action: PressActionKey, position: FlickKeyPosition) -> [CodableActionData] {
        get {
            if let direction = position.flickDirection {
                return self[direction][.pressAction]
            }
            return self.press_actions
        }
        set {
            if let direction = position.flickDirection {
                self[direction][.pressAction] = newValue
            } else {
                self.press_actions = newValue
            }
        }
    }

    subscript(inputAction: InputActionKey, position: FlickKeyPosition) -> String {
        get {
            if let direction = position.flickDirection {
                return self[direction][.inputAction]
            }
            if case let .input(value) = self.press_actions.first {
                return value
            }
            return ""
        }
        set {
            if let direction = position.flickDirection {
                self[direction][.inputAction] = newValue
            } else {
                self.press_actions = [.input(newValue)]
            }
        }
    }

    subscript(action: LongpressActionKey, position: FlickKeyPosition) -> CodableLongpressActionData {
        get {
            if let direction = position.flickDirection {
                return self[direction][.longpressAction]
            }
            return self.longpress_actions
        }
        set {
            if let direction = position.flickDirection {
                self[direction][.longpressAction] = newValue
            } else {
                self.longpress_actions = newValue
            }
        }
    }
}

fileprivate extension CustardInterfaceVariationKey {
    enum LabelTextKey { case labelText }
    enum PressActionKey { case pressAction }
    enum InputActionKey { case inputAction }
    enum LongpressActionKey { case longpressAction }
    enum LabelImageNameKey { case labelImageName }
    enum LabelTypeKey { case labelType }
    enum LabelMainKey { case labelMain }
    enum LabelSubKey { case labelSub }

    subscript(label: LabelTextKey) -> String {
        get {
            if case let .text(value) = self.design.label {
                return value
            }
            return ""
        }
        set {
            self.design.label = .text(newValue)
        }
    }

    subscript(label: LabelImageNameKey) -> String {
        get {
            if case let .systemImage(value) = self.design.label {
                return value
            }
            return ""
        }
        set {
            self.design.label = .systemImage(newValue)
        }
    }

    subscript(label: LabelMainKey) -> String {
        get {
            if case let .mainAndSub(value, _) = self.design.label {
                return value
            }
            return ""
        }
        set {
            if case let .mainAndSub(_, variations) = self.design.label {
                self.design.label = .mainAndSub(newValue, variations)
            } else {
                self.design.label = .mainAndSub(newValue, "")
            }
        }
    }

    subscript(label: LabelSubKey) -> String {
        get {
            if case let .mainAndSub(_, value) = self.design.label {
                return value
            }
            return ""
        }
        set {
            if case let .mainAndSub(main, _) = self.design.label {
                self.design.label = .mainAndSub(main, newValue)
            } else {
                self.design.label = .mainAndSub("", newValue)
            }
        }
    }

    subscript(label: LabelTypeKey) -> LabelType {
        get {
            switch self.design.label {
            case .systemImage: return .systemImage
            case .text: return .text
            case .mainAndSub: return .mainAndSub
            }
        }
        set {
            switch newValue {
            case .text:
                self.design.label = .text("")
            case .systemImage:
                self.design.label = .systemImage("circle.fill")
            case .mainAndSub:
                self.design.label = .mainAndSub("A", "BC")
            }
        }
    }

    subscript(pressAction: PressActionKey) -> [CodableActionData] {
        get {
            self.press_actions
        }
        set {
            self.press_actions = newValue
        }
    }

    subscript(inputAction: InputActionKey) -> String {
        get {
            if case let .input(value) = self.press_actions.first {
                return value
            }
            return ""
        }
        set {
            self.press_actions = [.input(newValue)]
        }
    }

    subscript(longpressAction: LongpressActionKey) -> CodableLongpressActionData {
        get {
            self.longpress_actions
        }
        set {
            self.longpress_actions = newValue
        }
    }
}

private struct IntStringConversion: Intertranslator {
    typealias First = Int
    typealias Second = String

    static func convert(_ first: Int) -> String {
        String(first)
    }
    static func convert(_ second: String) -> Int {
        max(Int(second) ?? 1, 1)
    }
}

struct CustardInterfaceKeyEditor: View {
    @Binding private var key: CustardInterfaceKey
    @Binding private var width: Int
    @Binding private var height: Int
    private let intStringConverter = IntStringConversion.self

    @State private var selectedPosition: FlickKeyPosition = .center
    @State private var bottomSheetShown = false

    init(data: Binding<UserMadeTenKeyCustard.KeyData>) {
        self._key = data.model
        self._width = data.width
        self._height = data.height
    }

    @MainActor private var screenWidth: CGFloat { UIScreen.main.bounds.width }

    @MainActor private var keySize: CGSize {
        CGSize(width: screenWidth / 5.6, height: screenWidth / 8)
    }
    @MainActor private var spacing: CGFloat {
        (screenWidth - keySize.width * 5) / 5
    }

    var body: some View {
        GeometryReader {geometry in
            VStack {
                switch key {
                case let .custom(value):
                    Text("ç·¨éãããæ¹åãé¸æãã¦ãã ããã")
                        .padding(.vertical)
                    keysView(key: value)
                    BottomSheetView(isOpen: self.$bottomSheetShown, maxHeight: geometry.size.height * 0.7) {
                        customKeyEditor(position: selectedPosition)
                    }
                case .system:
                    systemKeyEditor()
                }
            }
        }
        .onChange(of: selectedPosition) {_ in
            bottomSheetShown = true
        }
        .background(Color.secondarySystemBackground)
        .navigationTitle(Text("ã­ã¼ã®ç·¨é"))
    }

    private var keyPicker: some View {
        Picker("ã­ã¼ã®ç¨®é¡", selection: $key) {
            if [CustardInterfaceKey.system(.enter), .custom(.flickSpace()), .custom(.flickDelete()), .system(.changeKeyboard), .system(.flickKogaki), .system(.flickKutoten), .system(.flickHiraTab), .system(.flickAbcTab), .system(.flickStar123Tab)].contains(key) {
                Text("ã«ã¹ã¿ã ").tag(CustardInterfaceKey.custom(.empty))
            } else {
                Text("ã«ã¹ã¿ã ").tag(key)
            }
            Text("æ¹è¡ã­ã¼").tag(CustardInterfaceKey.system(.enter))
            Text("åé¤ã­ã¼").tag(CustardInterfaceKey.custom(.flickDelete()))
            Text("ç©ºç½ã­ã¼").tag(CustardInterfaceKey.custom(.flickSpace()))
            Text("æ¬¡åè£ã­ã¼").tag(CustardInterfaceKey.system(.nextCandidate))
            Text("å°çåã­ã¼").tag(CustardInterfaceKey.system(.changeKeyboard))
            Text("å°æ¸ãã»æ¿ç¹åã­ã¼").tag(CustardInterfaceKey.system(.flickKogaki))
            Text("å¤§æå­ã»å°æå­ã­ã¼").tag(CustardInterfaceKey.system(.upperLower))
            Text("å¥èª­ç¹ã­ã¼").tag(CustardInterfaceKey.system(.flickKutoten))
            Text("æ¥æ¬èªã¿ãã­ã¼").tag(CustardInterfaceKey.system(.flickHiraTab))
            Text("è±èªã¿ãã­ã¼").tag(CustardInterfaceKey.system(.flickAbcTab))
            Text("è¨å·ã¿ãã­ã¼").tag(CustardInterfaceKey.system(.flickStar123Tab))
        }
    }

    @ViewBuilder private var sizePicker: some View {
        HStack {
            Text("ç¸¦")
            IntegerTextField("ç¸¦", text: $height.converted(intStringConverter), range: 1 ... .max)
                .keyboardType(.numberPad)
                .textFieldStyle(.roundedBorder)
                .submitLabel(.done)
        }
        HStack {
            Text("æ¨ª")
            IntegerTextField("æ¨ª", text: $width.converted(intStringConverter), range: 1 ... .max)
                .keyboardType(.numberPad)
                .textFieldStyle(.roundedBorder)
                .submitLabel(.done)
        }
    }

    private func systemKeyEditor() -> some View {
        Form {
            Section {
                keyPicker
            }
            Section(header: Text("ã­ã¼ã®ãµã¤ãº")) {
                sizePicker
            }
            Section {
                Button("ãªã»ãã") {
                    key = .custom(.empty)
                }.foregroundStyle(.red)
            }
        }
    }

    private func isInputActionEditable(position: FlickKeyPosition) -> Bool {
        let actions = self.key[.custom][.pressAction, position]
        if actions.count == 1, case .input = actions.first {
            return true
        }
        if actions.isEmpty {
            return true
        }
        return false
    }

    private func customKeyEditor(position: FlickKeyPosition) -> some View {
        Form {
            Section(header: Text("å¥å")) {
                if self.isInputActionEditable(position: position) {
                    Text("ã­ã¼ãæ¼ãã¦å¥åãããæå­ãè¨­å®ãã¾ãã")
                    // FIXME: ãã°ãé²ãããä¸æçã«Bindingãªãã¸ã§ã¯ããæåçæããå½¢ã«ãã¦ãã
                    TextField("å¥å", text: Binding(
                                get: {
                                    key[.custom][.inputAction, position]
                                },
                                set: {
                                    key[.custom][.inputAction, position] = $0
                                })
                    )
                    .textFieldStyle(.roundedBorder)
                    .submitLabel(.done)
                } else {
                    Text("ãã®ã­ã¼ã«ã¯å¥åä»¥å¤ã®ã¢ã¯ã·ã§ã³ãè¨­å®ããã¦ãã¾ããç¾å¨ã®ã¢ã¯ã·ã§ã³ãæ¶å»ãã¦å¥åããæå­ãè¨­å®ããã«ã¯ãå¥åãè¨­å®ããããæ¼ãã¦ãã ãã")
                    Button("å¥åãè¨­å®ãã") {
                        key[.custom][.inputAction, position] = ""
                    }
                    .foregroundStyle(.accentColor)
                }
            }
            Section(header: Text("ã©ãã«")) {
                Text("ã­ã¼ã«è¡¨ç¤ºãããæå­ãè¨­å®ãã¾ãã")
                Picker("ã©ãã«ã®ç¨®é¡", selection: $key[.custom][.labelType, position]) {
                    Text("ãã­ã¹ã").tag(LabelType.text)
                    Text("ã·ã¹ãã ã¢ã¤ã³ã³").tag(LabelType.systemImage)
                    Text("ã¡ã¤ã³ã¨ãµã").tag(LabelType.mainAndSub)
                }
                switch key[.custom][.labelType, position] {
                case .text:
                    TextField("ã©ãã«", text: Binding(
                                get: {
                                    key[.custom][.labelText, position]
                                },
                                set: {
                                    key[.custom][.labelText, position] = $0
                                })
                    )
                    .textFieldStyle(.roundedBorder)
                    .submitLabel(.done)
                case .systemImage:
                    TextField("ã¢ã¤ã³ã³ã®åå", text: Binding(
                                get: {
                                    key[.custom][.labelImageName, position]
                                },
                                set: {
                                    key[.custom][.labelImageName, position] = $0
                                })
                    )
                    .textFieldStyle(.roundedBorder)
                    .submitLabel(.done)
                case .mainAndSub:
                    TextField("ã¡ã¤ã³ã®ã©ãã«", text: Binding(
                                get: {
                                    key[.custom][.labelMain, position]
                                },
                                set: {
                                    key[.custom][.labelMain, position] = $0
                                })
                    )
                    .textFieldStyle(.roundedBorder)
                    .submitLabel(.done)
                    TextField("ãµãã®ã©ãã«", text: Binding(
                                get: {
                                    key[.custom][.labelSub, position]
                                },
                                set: {
                                    key[.custom][.labelSub, position] = $0
                                })
                    )
                    .textFieldStyle(.roundedBorder)
                    .submitLabel(.done)

                }
            }
            if position == .center {
                Section(header: Text("ã­ã¼ã®è²")) {
                    Text("ã­ã¼ã®è²ãè¨­å®ãã¾ãã")
                    Picker("ã­ã¼ã®è²", selection: $key[.custom].design.color) {
                        Text("éå¸¸ã®ã­ã¼").tag(CustardKeyDesign.ColorType.normal)
                        Text("ç¹å¥ãªã­ã¼").tag(CustardKeyDesign.ColorType.special)
                        Text("æ¼ããã¦ããã­ã¼").tag(CustardKeyDesign.ColorType.selected)
                        Text("ç®ç«ããªãã­ã¼").tag(CustardKeyDesign.ColorType.unimportant)
                    }
                }
            }
            Section(header: Text("ã¢ã¯ã·ã§ã³")) {
                Text("ã­ã¼ãæ¼ããã¨ãã®åä½ãããè©³ããè¨­å®ãã¾ãã")
                NavigationLink("ã¢ã¯ã·ã§ã³ãç·¨éãã", destination: CodableActionDataEditor($key[.custom][.pressAction, position], availableCustards: CustardManager.load().availableCustards))
                    .foregroundStyle(.accentColor)
            }
            Section(header: Text("é·æ¼ãã¢ã¯ã·ã§ã³")) {
                Text("ã­ã¼ãé·æ¼ãããã¨ãã®åä½ãããè©³ããè¨­å®ãã¾ãã")
                NavigationLink("é·æ¼ãã¢ã¯ã·ã§ã³ãç·¨éãã", destination: CodableLongpressActionDataEditor($key[.custom][.longpressAction, position], availableCustards: CustardManager.load().availableCustards))
                    .foregroundStyle(.accentColor)
            }

            if position == .center {
                Section(header: Text("ã­ã¼ã®ãµã¤ãº")) {
                    sizePicker
                }
                Section {
                    keyPicker
                }
                Section {
                    Button("ãªã»ãã") {
                        key = .custom(.empty)
                    }.foregroundStyle(.red)
                }
            }
            if let direction = position.flickDirection {
                Button("ã¯ãªã¢") {
                    key[.custom].variations.removeAll {
                        $0.type == .flickVariation(direction)
                    }
                }.foregroundStyle(.red)
            }
        }
    }

    @MainActor private func keysView(key: CustardInterfaceCustomKey) -> some View {
        VStack {
            keyView(key: key, position: .top)
            HStack {
                keyView(key: key, position: .left)
                keyView(key: key, position: .center)
                keyView(key: key, position: .right)
            }
            keyView(key: key, position: .bottom)
        }
    }

    @MainActor @ViewBuilder private func keyView(key: CustardInterfaceCustomKey, position: FlickKeyPosition) -> some View {
        switch key[.labelType, position] {
        case .text:
            CustomKeySettingFlickKeyView(position, label: key[.labelText, position], selectedPosition: $selectedPosition)
                .frame(width: keySize.width, height: keySize.height)
        case .systemImage:
            CustomKeySettingFlickKeyView(position, selectedPosition: $selectedPosition) {
                Image(systemName: key[.labelImageName, position])
            }
            .frame(width: keySize.width, height: keySize.height)
        case .mainAndSub:
            CustomKeySettingFlickKeyView(position, selectedPosition: $selectedPosition) {
                VStack {
                    Text(verbatim: key[.labelMain, position])
                    Text(verbatim: key[.labelSub, position]).font(.caption)
                }
            }
            .frame(width: keySize.width, height: keySize.height)
        }
    }
}
